"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeFetchWrap = safeFetchWrap;
const fetch_1 = require("@atproto-labs/fetch");
const pipe_1 = require("@atproto-labs/pipe");
const unicast_js_1 = require("./unicast.js");
/**
 * Wrap a fetch function with safety checks so that it can be safely used
 * with user provided input (URL).
 *
 * @see {@link https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html}
 */
function safeFetchWrap({ fetch = globalThis.fetch, responseMaxSize = 512 * 1024, // 512kB
ssrfProtection = true, allowCustomPort = !ssrfProtection, allowData = false, allowHttp = !ssrfProtection, allowIpHost = true, allowPrivateIps = !ssrfProtection, timeout = 10e3, forbiddenDomainNames = fetch_1.DEFAULT_FORBIDDEN_DOMAIN_NAMES, } = {}) {
    return (0, fetch_1.toRequestTransformer)((0, pipe_1.pipe)(
    /**
     * Disable HTTP redirects
     */
    (0, fetch_1.redirectCheckRequestTransform)(), 
    /**
     * Only requests that will be issued with a "Host" header are allowed.
     */
    allowIpHost ? fetch_1.asRequest : (0, fetch_1.requireHostHeaderTransform)(), 
    /**
     * Prevent using http:, file: or data: protocols.
     */
    (0, fetch_1.protocolCheckRequestTransform)({
        'about:': false,
        'data:': allowData,
        'file:': false,
        'http:': allowHttp && { allowCustomPort },
        'https:': { allowCustomPort },
    }), 
    /**
     * Disallow fetching from domains we know are not atproto/OIDC client
     * implementation. Note that other domains can be blocked by providing a
     * custom fetch function combined with another
     * forbiddenDomainNameRequestTransform.
     */
    (0, fetch_1.forbiddenDomainNameRequestTransform)(forbiddenDomainNames), 
    /**
     * Since we will be fetching from the network based on user provided
     * input, let's mitigate resource exhaustion attacks by setting a timeout.
     */
    (0, fetch_1.timedFetch)(timeout, 
    /**
     * Since we will be fetching from the network based on user provided
     * input, we need to make sure that the request is not vulnerable to SSRF
     * attacks.
     */
    allowPrivateIps ? fetch : (0, unicast_js_1.unicastFetchWrap)({ fetch })), 
    /**
     * Since we will be fetching user owned data, we need to make sure that an
     * attacker cannot force us to download a large amounts of data.
     */
    (0, fetch_1.fetchMaxSizeProcessor)(responseMaxSize)));
}
//# sourceMappingURL=safe.js.map