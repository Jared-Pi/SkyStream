"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebcryptoKey = exports.jwkWithAlgSchema = void 0;
const zod_1 = require("zod");
const jwk_1 = require("@atproto/jwk");
const jwk_jose_1 = require("@atproto/jwk-jose");
const util_js_1 = require("./util.js");
// Webcrypto keys are bound to a single algorithm
exports.jwkWithAlgSchema = zod_1.z.intersection(jwk_1.jwkSchema, zod_1.z.object({ alg: zod_1.z.string() }));
class WebcryptoKey extends jwk_jose_1.JoseKey {
    // We need to override the static method generate from JoseKey because
    // the browser needs both the private and public keys
    static async generate(allowedAlgos = ['ES256'], kid = crypto.randomUUID(), options) {
        const keyPair = await this.generateKeyPair(allowedAlgos, options);
        // Type safety only: in the browser, 'jose' always generates a CryptoKeyPair
        if (!(0, util_js_1.isCryptoKeyPair)(keyPair)) {
            throw new TypeError('Invalid CryptoKeyPair');
        }
        return this.fromKeypair(keyPair, kid);
    }
    static async fromKeypair(cryptoKeyPair, kid) {
        // https://datatracker.ietf.org/doc/html/rfc7517
        // > The "use" and "key_ops" JWK members SHOULD NOT be used together; [...]
        // > Applications should specify which of these members they use.
        const { key_ops, use, alg = (0, util_js_1.fromSubtleAlgorithm)(cryptoKeyPair.privateKey.algorithm), ...jwk } = await crypto.subtle.exportKey('jwk', cryptoKeyPair.privateKey.extractable
            ? cryptoKeyPair.privateKey
            : cryptoKeyPair.publicKey);
        if (use && use !== 'sig') {
            throw new TypeError(`Unsupported JWK use "${use}"`);
        }
        if (key_ops && !key_ops.some((o) => o === 'sign' || o === 'verify')) {
            // Make sure that "key_ops", if present, is compatible with "use"
            throw new TypeError(`Invalid key_ops "${key_ops}" for "sig" use`);
        }
        return new WebcryptoKey(exports.jwkWithAlgSchema.parse({ ...jwk, kid, alg, use: 'sig' }), cryptoKeyPair);
    }
    constructor(jwk, cryptoKeyPair) {
        super(jwk);
        Object.defineProperty(this, "cryptoKeyPair", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cryptoKeyPair
        });
    }
    get isPrivate() {
        return true;
    }
    get privateJwk() {
        if (super.isPrivate)
            return this.jwk;
        throw new Error('Private Webcrypto Key not exportable');
    }
    async getKeyObj(alg) {
        if (this.jwk.alg !== alg) {
            throw new jwk_1.JwkError(`Key cannot be used with algorithm "${alg}"`);
        }
        return this.cryptoKeyPair.privateKey;
    }
}
exports.WebcryptoKey = WebcryptoKey;
//# sourceMappingURL=webcrypto-key.js.map